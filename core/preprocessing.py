# CogniBench - Preprocessing Module
# Version: 0.1 (Phase 2 - Initial Answer Extraction)

import re
import unicodedata
from typing import Optional

# Simple patterns to identify the final answer section
# This is a basic heuristic and likely needs significant improvement for robustness.
# Consider using more sophisticated regex, NLP techniques, or even a dedicated LLM call later.
FINAL_ANSWER_PATTERNS = [
    re.compile(r"final answer[:\s]+(.*)", re.IGNORECASE | re.DOTALL),
    re.compile(r"the final answer is[:\s]+(.*)", re.IGNORECASE | re.DOTALL),
    re.compile(
        r"answer[:\s]+(.*)", re.IGNORECASE | re.DOTALL
    ),  # More generic, might capture too much
    # Add more patterns as needed
]


def extract_final_answer(response_text: str) -> Optional[str]:
    """
    Attempts to extract the final answer from the model's response text
    using simple heuristics.

    Args:
        response_text: The full text generated by the model.

    Returns:
        The extracted final answer string, or None if no clear answer is found.
    """
    if not response_text:
        return None

    # Iterate through patterns to find the first match
    for pattern in FINAL_ANSWER_PATTERNS:
        match = pattern.search(response_text)
        if match:
            # Extract the text after the pattern, strip leading/trailing whitespace
            # Further cleaning might be needed (e.g., removing explanations after the answer)
            extracted = match.group(1).strip()
            # Simple heuristic to stop at the next newline if found early,
            # trying to avoid capturing subsequent paragraphs.
            first_newline = extracted.find("\n")
            if first_newline != -1 and first_newline < 150:  # Arbitrary length limit
                extracted = extracted[:first_newline].strip()
            return extracted

    # Fallback: Maybe the last line is the answer? (Very naive)
    lines = response_text.strip().split("\n")
    if lines:
        last_line = lines[-1].strip()
        # Add checks here? e.g., if it looks like a formula or number
        # For now, let's not use this fallback as it's too unreliable.
        pass

    print("Warning: Could not extract final answer using basic heuristics.")
    return None


def normalize_text_formats(text: Optional[str]) -> Optional[str]:
    """
    Performs basic text normalization:
    - NFC Unicode normalization.
    - Strips leading/trailing whitespace.
    - Replaces multiple whitespace characters with a single space.
    - TODO: Add basic LaTeX/MathML rendering/normalization if needed.

    Args:
        text: The input string.

    Returns:
        The normalized string, or None if input is None.
    """
    if text is None:
        return None

    # Unicode normalization (NFC is generally recommended)
    text = unicodedata.normalize("NFC", text)

    # Replace multiple whitespace chars (space, tab, newline etc.) with a single space
    text = re.sub(r"\s+", " ", text)

    # Strip leading/trailing whitespace
    text = text.strip()

    return text


if __name__ == "__main__":
    print("\n--- Extract Final Answer ---")
    test_text_1 = "Blah blah blah. Step 1... Step 2... Final Answer: x = 5"
    test_text_2 = (
        "The calculation shows y=10. The final answer is: y = 10 \n This is because..."
    )
    test_text_3 = "Let z = 3. Answer: z=3"
    test_text_4 = "No clear answer stated."

    print(f"Test 1: {extract_final_answer(test_text_1)}")
    print(f"Test 2: {extract_final_answer(test_text_2)}")
    print(f"Test 3: {extract_final_answer(test_text_3)}")
    print(f"Test 4: {extract_final_answer(test_text_4)}")
    print("\n--- Text Normalization ---")
    test_norm_1 = "  Extra   spaces\nand\ttabs  "
    test_norm_2 = "Already clean."
    test_norm_3 = None
    print(f"'{test_norm_1}' -> '{normalize_text_formats(test_norm_1)}'")
    print(f"'{test_norm_2}' -> '{normalize_text_formats(test_norm_2)}'")
    print(f"'{test_norm_3}' -> '{normalize_text_formats(test_norm_3)}'")
